/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/v4.5.10/LICENSE
 */
;(function(t, r) {
  if (typeof define === 'function' && define.amd) {
    define(r)
  } else if (typeof exports === 'object') {
    module.exports = r()
  } else {
    t.returnExports = r()
  }
})(this, function() {
  const t = Array
  const r = t.prototype
  const e = Object
  const n = e.prototype
  const i = Function
  const a = i.prototype
  const o = String
  const f = o.prototype
  const u = Number
  const l = u.prototype
  const s = r.slice
  const c = r.splice
  const v = r.push
  const h = r.unshift
  const p = r.concat
  const y = r.join
  const d = a.call
  const g = a.apply
  const w = Math.max
  const b = Math.min
  const T = n.toString
  const m =
    typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol'
  var D
  const S = Function.prototype.toString
  const x = /^\s*class /
  const O = function isES6ClassFn(t) {
    try {
      const r = S.call(t)
      const e = r.replace(/\/\/.*\n/g, '')
      const n = e.replace(/\/\*[.\s\S]*\*\//g, '')
      const i = n.replace(/\n/gm, ' ').replace(/ {2}/g, ' ')
      return x.test(i)
    } catch (a) {
      return false
    }
  }
  const E = function tryFunctionObject(t) {
    try {
      if (O(t)) {
        return false
      }
      S.call(t)
      return true
    } catch (r) {
      return false
    }
  }
  const j = '[object Function]'
  const I = '[object GeneratorFunction]'
  var D = function isCallable(t) {
    if (!t) {
      return false
    }
    if (typeof t !== 'function' && typeof t !== 'object') {
      return false
    }
    if (m) {
      return E(t)
    }
    if (O(t)) {
      return false
    }
    const r = T.call(t)
    return r === j || r === I
  }
  let M
  const U = RegExp.prototype.exec
  const F = function tryRegexExec(t) {
    try {
      U.call(t)
      return true
    } catch (r) {
      return false
    }
  }
  const N = '[object RegExp]'
  M = function isRegex(t) {
    if (typeof t !== 'object') {
      return false
    }
    return m ? F(t) : T.call(t) === N
  }
  let C
  const k = String.prototype.valueOf
  const A = function tryStringObject(t) {
    try {
      k.call(t)
      return true
    } catch (r) {
      return false
    }
  }
  const R = '[object String]'
  C = function isString(t) {
    if (typeof t === 'string') {
      return true
    }
    if (typeof t !== 'object') {
      return false
    }
    return m ? A(t) : T.call(t) === R
  }
  const $ =
    e.defineProperty &&
    (function() {
      try {
        const t = {}
        e.defineProperty(t, 'x', { enumerable: false, value: t })
        for (const r in t) {
          return false
        }
        return t.x === t
      } catch (n) {
        return false
      }
    })()
  const P = (function(t) {
    let r
    if ($) {
      r = function(t, r, n, i) {
        if (!i && r in t) {
          return
        }
        e.defineProperty(t, r, {
          configurable: true,
          enumerable: false,
          writable: true,
          value: n,
        })
      }
    } else {
      r = function(t, r, e, n) {
        if (!n && r in t) {
          return
        }
        t[r] = e
      }
    }
    return function defineProperties(e, n, i) {
      for (const a in n) {
        if (t.call(n, a)) {
          r(e, a, n[a], i)
        }
      }
    }
  })(n.hasOwnProperty)
  const J = function isPrimitive(t) {
    const r = typeof t
    return t === null || (r !== 'object' && r !== 'function')
  }
  const Y =
    u.isNaN ||
    function isActualNaN(t) {
      return t !== t
    }
  const Z = {
    ToInteger: function ToInteger(t) {
      let r = +t
      if (Y(r)) {
        r = 0
      } else if (r !== 0 && r !== 1 / 0 && r !== -(1 / 0)) {
        r = (r > 0 || -1) * Math.floor(Math.abs(r))
      }
      return r
    },
    ToPrimitive: function ToPrimitive(t) {
      let r, e, n
      if (J(t)) {
        return t
      }
      e = t.valueOf
      if (D(e)) {
        r = e.call(t)
        if (J(r)) {
          return r
        }
      }
      n = t.toString
      if (D(n)) {
        r = n.call(t)
        if (J(r)) {
          return r
        }
      }
      throw new TypeError()
    },
    ToObject: function(t) {
      if (t == null) {
        throw new TypeError("can't convert " + t + ' to object')
      }
      return e(t)
    },
    ToUint32: function ToUint32(t) {
      return t >>> 0
    },
  }
  const z = function Empty() {}
  P(a, {
    bind: function bind(t) {
      const r = this
      if (!D(r)) {
        throw new TypeError(
          'Function.prototype.bind called on incompatible ' + r,
        )
      }
      const n = s.call(arguments, 1)
      let a
      const o = function() {
        if (this instanceof a) {
          const i = g.call(r, this, p.call(n, s.call(arguments)))
          if (e(i) === i) {
            return i
          }
          return this
        } else {
          return g.call(r, t, p.call(n, s.call(arguments)))
        }
      }
      const f = w(0, r.length - n.length)
      const u = []
      for (let l = 0; l < f; l++) {
        v.call(u, '$' + l)
      }
      a = i(
        'binder',
        'return function (' +
          y.call(u, ',') +
          '){ return binder.apply(this, arguments); }',
      )(o)
      if (r.prototype) {
        z.prototype = r.prototype
        a.prototype = new z()
        z.prototype = null
      }
      return a
    },
  })
  const G = d.bind(n.hasOwnProperty)
  const B = d.bind(n.toString)
  let H = d.bind(s)
  let W = g.bind(s)
  if (typeof document === 'object' && document && document.documentElement) {
    try {
      H(document.documentElement.childNodes)
    } catch (L) {
      const X = H
      const q = W
      H = function arraySliceIE(t) {
        const r = []
        let e = t.length
        while (e-- > 0) {
          r[e] = t[e]
        }
        return q(r, X(arguments, 1))
      }
      W = function arraySliceApplyIE(t, r) {
        return q(H(t), r)
      }
    }
  }
  const K = d.bind(f.slice)
  const Q = d.bind(f.split)
  const V = d.bind(f.indexOf)
  const _ = d.bind(v)
  const tt = d.bind(n.propertyIsEnumerable)
  const rt = d.bind(r.sort)
  const et =
    t.isArray ||
    function isArray(t) {
      return B(t) === '[object Array]'
    }
  const nt = [].unshift(0) !== 1
  P(
    r,
    {
      unshift: function() {
        h.apply(this, arguments)
        return this.length
      },
    },
    nt,
  )
  P(t, { isArray: et })
  const it = e('a')
  const at = it[0] !== 'a' || !(0 in it)
  const ot = function properlyBoxed(t) {
    let r = true
    let e = true
    let n = false
    if (t) {
      try {
        t.call('foo', function(t, e, n) {
          if (typeof n !== 'object') {
            r = false
          }
        })
        t.call(
          [1],
          function() {
            e = typeof this === 'string'
          },
          'x',
        )
      } catch (i) {
        n = true
      }
    }
    return !!t && !n && r && e
  }
  P(
    r,
    {
      forEach: function forEach(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        let n = -1
        const i = Z.ToUint32(e.length)
        let a
        if (arguments.length > 1) {
          a = arguments[1]
        }
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.forEach callback must be a function',
          )
        }
        while (++n < i) {
          if (n in e) {
            if (typeof a === 'undefined') {
              t(e[n], n, r)
            } else {
              t.call(a, e[n], n, r)
            }
          }
        }
      },
    },
    !ot(r.forEach),
  )
  P(
    r,
    {
      map: function map(r) {
        const e = Z.ToObject(this)
        const n = at && C(this) ? Q(this, '') : e
        const i = Z.ToUint32(n.length)
        const a = t(i)
        let o
        if (arguments.length > 1) {
          o = arguments[1]
        }
        if (!D(r)) {
          throw new TypeError('Array.prototype.map callback must be a function')
        }
        for (let f = 0; f < i; f++) {
          if (f in n) {
            if (typeof o === 'undefined') {
              a[f] = r(n[f], f, e)
            } else {
              a[f] = r.call(o, n[f], f, e)
            }
          }
        }
        return a
      },
    },
    !ot(r.map),
  )
  P(
    r,
    {
      filter: function filter(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        const n = Z.ToUint32(e.length)
        const i = []
        let a
        let o
        if (arguments.length > 1) {
          o = arguments[1]
        }
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.filter callback must be a function',
          )
        }
        for (let f = 0; f < n; f++) {
          if (f in e) {
            a = e[f]
            if (typeof o === 'undefined' ? t(a, f, r) : t.call(o, a, f, r)) {
              _(i, a)
            }
          }
        }
        return i
      },
    },
    !ot(r.filter),
  )
  P(
    r,
    {
      every: function every(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        const n = Z.ToUint32(e.length)
        let i
        if (arguments.length > 1) {
          i = arguments[1]
        }
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.every callback must be a function',
          )
        }
        for (let a = 0; a < n; a++) {
          if (
            a in e &&
            !(typeof i === 'undefined' ? t(e[a], a, r) : t.call(i, e[a], a, r))
          ) {
            return false
          }
        }
        return true
      },
    },
    !ot(r.every),
  )
  P(
    r,
    {
      some: function some(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        const n = Z.ToUint32(e.length)
        let i
        if (arguments.length > 1) {
          i = arguments[1]
        }
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.some callback must be a function',
          )
        }
        for (let a = 0; a < n; a++) {
          if (
            a in e &&
            (typeof i === 'undefined' ? t(e[a], a, r) : t.call(i, e[a], a, r))
          ) {
            return true
          }
        }
        return false
      },
    },
    !ot(r.some),
  )
  let ft = false
  if (r.reduce) {
    ft =
      typeof r.reduce.call('es5', function(t, r, e, n) {
        return n
      }) === 'object'
  }
  P(
    r,
    {
      reduce: function reduce(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        const n = Z.ToUint32(e.length)
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.reduce callback must be a function',
          )
        }
        if (n === 0 && arguments.length === 1) {
          throw new TypeError('reduce of empty array with no initial value')
        }
        let i = 0
        let a
        if (arguments.length >= 2) {
          a = arguments[1]
        } else {
          do {
            if (i in e) {
              a = e[i++]
              break
            }
            if (++i >= n) {
              throw new TypeError('reduce of empty array with no initial value')
            }
          } while (true)
        }
        for (; i < n; i++) {
          if (i in e) {
            a = t(a, e[i], i, r)
          }
        }
        return a
      },
    },
    !ft,
  )
  let ut = false
  if (r.reduceRight) {
    ut =
      typeof r.reduceRight.call('es5', function(t, r, e, n) {
        return n
      }) === 'object'
  }
  P(
    r,
    {
      reduceRight: function reduceRight(t) {
        const r = Z.ToObject(this)
        const e = at && C(this) ? Q(this, '') : r
        const n = Z.ToUint32(e.length)
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.reduceRight callback must be a function',
          )
        }
        if (n === 0 && arguments.length === 1) {
          throw new TypeError(
            'reduceRight of empty array with no initial value',
          )
        }
        let i
        let a = n - 1
        if (arguments.length >= 2) {
          i = arguments[1]
        } else {
          do {
            if (a in e) {
              i = e[a--]
              break
            }
            if (--a < 0) {
              throw new TypeError(
                'reduceRight of empty array with no initial value',
              )
            }
          } while (true)
        }
        if (a < 0) {
          return i
        }
        do {
          if (a in e) {
            i = t(i, e[a], a, r)
          }
        } while (a--)
        return i
      },
    },
    !ut,
  )
  const lt = r.indexOf && [0, 1].indexOf(1, 2) !== -1
  P(
    r,
    {
      indexOf: function indexOf(t) {
        const r = at && C(this) ? Q(this, '') : Z.ToObject(this)
        const e = Z.ToUint32(r.length)
        if (e === 0) {
          return -1
        }
        let n = 0
        if (arguments.length > 1) {
          n = Z.ToInteger(arguments[1])
        }
        n = n >= 0 ? n : w(0, e + n)
        for (; n < e; n++) {
          if (n in r && r[n] === t) {
            return n
          }
        }
        return -1
      },
    },
    lt,
  )
  const st = r.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1
  P(
    r,
    {
      lastIndexOf: function lastIndexOf(t) {
        const r = at && C(this) ? Q(this, '') : Z.ToObject(this)
        const e = Z.ToUint32(r.length)
        if (e === 0) {
          return -1
        }
        let n = e - 1
        if (arguments.length > 1) {
          n = b(n, Z.ToInteger(arguments[1]))
        }
        n = n >= 0 ? n : e - Math.abs(n)
        for (; n >= 0; n--) {
          if (n in r && t === r[n]) {
            return n
          }
        }
        return -1
      },
    },
    st,
  )
  const ct = (function() {
    const t = [1, 2]
    const r = t.splice()
    return t.length === 2 && et(r) && r.length === 0
  })()
  P(
    r,
    {
      splice: function splice(t, r) {
        if (arguments.length === 0) {
          return []
        } else {
          return c.apply(this, arguments)
        }
      },
    },
    !ct,
  )
  const vt = (function() {
    const t = {}
    r.splice.call(t, 0, 0, 1)
    return t.length === 1
  })()
  P(
    r,
    {
      splice: function splice(t, r) {
        if (arguments.length === 0) {
          return []
        }
        let e = arguments
        this.length = w(Z.ToInteger(this.length), 0)
        if (arguments.length > 0 && typeof r !== 'number') {
          e = H(arguments)
          if (e.length < 2) {
            _(e, this.length - t)
          } else {
            e[1] = Z.ToInteger(r)
          }
        }
        return c.apply(this, e)
      },
    },
    !vt,
  )
  const ht = (function() {
    const r = new t(1e5)
    r[8] = 'x'
    r.splice(1, 1)
    return r.indexOf('x') === 7
  })()
  const pt = (function() {
    const t = 256
    const r = []
    r[t] = 'a'
    r.splice(t + 1, 0, 'b')
    return r[t] === 'a'
  })()
  P(
    r,
    {
      splice: function splice(t, r) {
        const e = Z.ToObject(this)
        const n = []
        const i = Z.ToUint32(e.length)
        const a = Z.ToInteger(t)
        const f = a < 0 ? w(i + a, 0) : b(a, i)
        const u = b(w(Z.ToInteger(r), 0), i - f)
        let l = 0
        let s
        while (l < u) {
          s = o(f + l)
          if (G(e, s)) {
            n[l] = e[s]
          }
          l += 1
        }
        const c = H(arguments, 2)
        const v = c.length
        let h
        if (v < u) {
          l = f
          const p = i - u
          while (l < p) {
            s = o(l + u)
            h = o(l + v)
            if (G(e, s)) {
              e[h] = e[s]
            } else {
              delete e[h]
            }
            l += 1
          }
          l = i
          const y = i - u + v
          while (l > y) {
            delete e[l - 1]
            l -= 1
          }
        } else if (v > u) {
          l = i - u
          while (l > f) {
            s = o(l + u - 1)
            h = o(l + v - 1)
            if (G(e, s)) {
              e[h] = e[s]
            } else {
              delete e[h]
            }
            l -= 1
          }
        }
        l = f
        for (let d = 0; d < c.length; ++d) {
          e[l] = c[d]
          l += 1
        }
        e.length = i - u + v
        return n
      },
    },
    !ht || !pt,
  )
  const yt = r.join
  let dt
  try {
    dt = Array.prototype.join.call('123', ',') !== '1,2,3'
  } catch (L) {
    dt = true
  }
  if (dt) {
    P(
      r,
      {
        join: function join(t) {
          const r = typeof t === 'undefined' ? ',' : t
          return yt.call(C(this) ? Q(this, '') : this, r)
        },
      },
      dt,
    )
  }
  const gt = [1, 2].join(undefined) !== '1,2'
  if (gt) {
    P(
      r,
      {
        join: function join(t) {
          const r = typeof t === 'undefined' ? ',' : t
          return yt.call(this, r)
        },
      },
      gt,
    )
  }
  const wt = function push(t) {
    const r = Z.ToObject(this)
    const e = Z.ToUint32(r.length)
    let n = 0
    while (n < arguments.length) {
      r[e + n] = arguments[n]
      n += 1
    }
    r.length = e + n
    return e + n
  }
  const bt = (function() {
    const t = {}
    const r = Array.prototype.push.call(t, undefined)
    return r !== 1 || t.length !== 1 || typeof t[0] !== 'undefined' || !G(t, 0)
  })()
  P(
    r,
    {
      push: function push(t) {
        if (et(this)) {
          return v.apply(this, arguments)
        }
        return wt.apply(this, arguments)
      },
    },
    bt,
  )
  const Tt = (function() {
    const t = []
    const r = t.push(undefined)
    return r !== 1 || t.length !== 1 || typeof t[0] !== 'undefined' || !G(t, 0)
  })()
  P(r, { push: wt }, Tt)
  P(
    r,
    {
      slice: function(t, r) {
        const e = C(this) ? Q(this, '') : this
        return W(e, arguments)
      },
    },
    at,
  )
  const mt = (function() {
    try {
      ;[1, 2].sort(null)
    } catch (t) {
      try {
        ;[1, 2].sort({})
      } catch (r) {
        return false
      }
    }
    return true
  })()
  const Dt = (function() {
    try {
      ;[1, 2].sort(/a/)
      return false
    } catch (t) {}
    return true
  })()
  const St = (function() {
    try {
      ;[1, 2].sort(undefined)
      return true
    } catch (t) {}
    return false
  })()
  P(
    r,
    {
      sort: function sort(t) {
        if (typeof t === 'undefined') {
          return rt(this)
        }
        if (!D(t)) {
          throw new TypeError(
            'Array.prototype.sort callback must be a function',
          )
        }
        return rt(this, t)
      },
    },
    mt || !St || !Dt,
  )
  const xt = !tt({ toString: null }, 'toString')
  const Ot = tt(function() {}, 'prototype')
  const Et = !G('x', '0')
  const jt = function(t) {
    const r = t.constructor
    return r && r.prototype === t
  }
  const It = {
    $window: true,
    $console: true,
    $parent: true,
    $self: true,
    $frame: true,
    $frames: true,
    $frameElement: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $external: true,
    $width: true,
    $height: true,
    $top: true,
    $localStorage: true,
  }
  const Mt = (function() {
    if (typeof window === 'undefined') {
      return false
    }
    for (const t in window) {
      try {
        if (
          !It['$' + t] &&
          G(window, t) &&
          window[t] !== null &&
          typeof window[t] === 'object'
        ) {
          jt(window[t])
        }
      } catch (r) {
        return true
      }
    }
    return false
  })()
  const Ut = function(t) {
    if (typeof window === 'undefined' || !Mt) {
      return jt(t)
    }
    try {
      return jt(t)
    } catch (r) {
      return false
    }
  }
  const Ft = [
    'toString',
    'toLocaleString',
    'valueOf',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'constructor',
  ]
  const Nt = Ft.length
  const Ct = function isArguments(t) {
    return B(t) === '[object Arguments]'
  }
  const kt = function isArguments(t) {
    return (
      t !== null &&
      typeof t === 'object' &&
      typeof t.length === 'number' &&
      t.length >= 0 &&
      !et(t) &&
      D(t.callee)
    )
  }
  const At = Ct(arguments) ? Ct : kt
  P(e, {
    keys: function keys(t) {
      const r = D(t)
      const e = At(t)
      const n = t !== null && typeof t === 'object'
      const i = n && C(t)
      if (!n && !r && !e) {
        throw new TypeError('Object.keys called on a non-object')
      }
      const a = []
      const f = Ot && r
      if ((i && Et) || e) {
        for (let u = 0; u < t.length; ++u) {
          _(a, o(u))
        }
      }
      if (!e) {
        for (const l in t) {
          if (!(f && l === 'prototype') && G(t, l)) {
            _(a, o(l))
          }
        }
      }
      if (xt) {
        const s = Ut(t)
        for (let c = 0; c < Nt; c++) {
          const v = Ft[c]
          if (!(s && v === 'constructor') && G(t, v)) {
            _(a, v)
          }
        }
      }
      return a
    },
  })
  const Rt =
    e.keys &&
    (function() {
      return e.keys(arguments).length === 2
    })(1, 2)
  const $t =
    e.keys &&
    (function() {
      const t = e.keys(arguments)
      return arguments.length !== 1 || t.length !== 1 || t[0] !== 1
    })(1)
  const Pt = e.keys
  P(
    e,
    {
      keys: function keys(t) {
        if (At(t)) {
          return Pt(H(t))
        } else {
          return Pt(t)
        }
      },
    },
    !Rt || $t,
  )
  const Jt = new Date(-0xc782b5b342b24).getUTCMonth() !== 0
  const Yt = new Date(-0x55d318d56a724)
  const Zt = new Date(14496624e5)
  const zt = Yt.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT'
  let Gt
  let Bt
  const Ht = Yt.getTimezoneOffset()
  if (Ht < -720) {
    Gt = Yt.toDateString() !== 'Tue Jan 02 -45875'
    Bt = !/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(
      String(Zt),
    )
  } else {
    Gt = Yt.toDateString() !== 'Mon Jan 01 -45875'
    Bt = !/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(
      String(Zt),
    )
  }
  const Wt = d.bind(Date.prototype.getFullYear)
  const Lt = d.bind(Date.prototype.getMonth)
  const Xt = d.bind(Date.prototype.getDate)
  const qt = d.bind(Date.prototype.getUTCFullYear)
  const Kt = d.bind(Date.prototype.getUTCMonth)
  const Qt = d.bind(Date.prototype.getUTCDate)
  const Vt = d.bind(Date.prototype.getUTCDay)
  const _t = d.bind(Date.prototype.getUTCHours)
  const tr = d.bind(Date.prototype.getUTCMinutes)
  const rr = d.bind(Date.prototype.getUTCSeconds)
  const er = d.bind(Date.prototype.getUTCMilliseconds)
  const nr = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  const ir = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ]
  const ar = function daysInMonth(t, r) {
    return Xt(new Date(r, t, 0))
  }
  P(
    Date.prototype,
    {
      getFullYear: function getFullYear() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = Wt(this)
        if (t < 0 && Lt(this) > 11) {
          return t + 1
        }
        return t
      },
      getMonth: function getMonth() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = Wt(this)
        const r = Lt(this)
        if (t < 0 && r > 11) {
          return 0
        }
        return r
      },
      getDate: function getDate() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = Wt(this)
        const r = Lt(this)
        const e = Xt(this)
        if (t < 0 && r > 11) {
          if (r === 12) {
            return e
          }
          const n = ar(0, t + 1)
          return n - e + 1
        }
        return e
      },
      getUTCFullYear: function getUTCFullYear() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = qt(this)
        if (t < 0 && Kt(this) > 11) {
          return t + 1
        }
        return t
      },
      getUTCMonth: function getUTCMonth() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = qt(this)
        const r = Kt(this)
        if (t < 0 && r > 11) {
          return 0
        }
        return r
      },
      getUTCDate: function getUTCDate() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = qt(this)
        const r = Kt(this)
        const e = Qt(this)
        if (t < 0 && r > 11) {
          if (r === 12) {
            return e
          }
          const n = ar(0, t + 1)
          return n - e + 1
        }
        return e
      },
    },
    Jt,
  )
  P(
    Date.prototype,
    {
      toUTCString: function toUTCString() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = Vt(this)
        const r = Qt(this)
        const e = Kt(this)
        const n = qt(this)
        const i = _t(this)
        const a = tr(this)
        const o = rr(this)
        return (
          nr[t] +
          ', ' +
          (r < 10 ? '0' + r : r) +
          ' ' +
          ir[e] +
          ' ' +
          n +
          ' ' +
          (i < 10 ? '0' + i : i) +
          ':' +
          (a < 10 ? '0' + a : a) +
          ':' +
          (o < 10 ? '0' + o : o) +
          ' GMT'
        )
      },
    },
    Jt || zt,
  )
  P(
    Date.prototype,
    {
      toDateString: function toDateString() {
        if (!this || !(this instanceof Date)) {
          throw new TypeError('this is not a Date object.')
        }
        const t = this.getDay()
        const r = this.getDate()
        const e = this.getMonth()
        const n = this.getFullYear()
        return nr[t] + ' ' + ir[e] + ' ' + (r < 10 ? '0' + r : r) + ' ' + n
      },
    },
    Jt || Gt,
  )
  if (Jt || Bt) {
    Date.prototype.toString = function toString() {
      if (!this || !(this instanceof Date)) {
        throw new TypeError('this is not a Date object.')
      }
      const t = this.getDay()
      const r = this.getDate()
      const e = this.getMonth()
      const n = this.getFullYear()
      const i = this.getHours()
      const a = this.getMinutes()
      const o = this.getSeconds()
      const f = this.getTimezoneOffset()
      const u = Math.floor(Math.abs(f) / 60)
      const l = Math.floor(Math.abs(f) % 60)
      return (
        nr[t] +
        ' ' +
        ir[e] +
        ' ' +
        (r < 10 ? '0' + r : r) +
        ' ' +
        n +
        ' ' +
        (i < 10 ? '0' + i : i) +
        ':' +
        (a < 10 ? '0' + a : a) +
        ':' +
        (o < 10 ? '0' + o : o) +
        ' GMT' +
        (f > 0 ? '-' : '+') +
        (u < 10 ? '0' + u : u) +
        (l < 10 ? '0' + l : l)
      )
    }
    if ($) {
      e.defineProperty(Date.prototype, 'toString', {
        configurable: true,
        enumerable: false,
        writable: true,
      })
    }
  }
  const or = -621987552e5
  const fr = '-000001'
  const ur =
    Date.prototype.toISOString && new Date(or).toISOString().indexOf(fr) === -1
  const lr =
    Date.prototype.toISOString &&
    new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z'
  const sr = d.bind(Date.prototype.getTime)
  P(
    Date.prototype,
    {
      toISOString: function toISOString() {
        if (!isFinite(this) || !isFinite(sr(this))) {
          throw new RangeError(
            'Date.prototype.toISOString called on non-finite value.',
          )
        }
        let t = qt(this)
        let r = Kt(this)
        t += Math.floor(r / 12)
        r = ((r % 12) + 12) % 12
        const e = [r + 1, Qt(this), _t(this), tr(this), rr(this)]
        t =
          (t < 0 ? '-' : t > 9999 ? '+' : '') +
          K('00000' + Math.abs(t), t >= 0 && t <= 9999 ? -4 : -6)
        for (let n = 0; n < e.length; ++n) {
          e[n] = K('00' + e[n], -2)
        }
        return (
          t +
          '-' +
          H(e, 0, 2).join('-') +
          'T' +
          H(e, 2).join(':') +
          '.' +
          K('000' + er(this), -3) +
          'Z'
        )
      },
    },
    ur || lr,
  )
  const cr = (function() {
    try {
      return (
        Date.prototype.toJSON &&
        new Date(NaN).toJSON() === null &&
        new Date(or).toJSON().indexOf(fr) !== -1 &&
        Date.prototype.toJSON.call({
          toISOString: function() {
            return true
          },
        })
      )
    } catch (t) {
      return false
    }
  })()
  if (!cr) {
    Date.prototype.toJSON = function toJSON(t) {
      const r = e(this)
      const n = Z.ToPrimitive(r)
      if (typeof n === 'number' && !isFinite(n)) {
        return null
      }
      const i = r.toISOString
      if (!D(i)) {
        throw new TypeError('toISOString property is not callable')
      }
      return i.call(r)
    }
  }
  const vr = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15
  const hr =
    !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) ||
    !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) ||
    !isNaN(Date.parse('2012-12-31T23:59:60.000Z'))
  const pr = isNaN(Date.parse('2000-01-01T00:00:00.000Z'))
  if (pr || hr || !vr) {
    const yr = Math.pow(2, 31) - 1
    const dr = Y(new Date(1970, 0, 1, 0, 0, 0, yr + 1).getTime())
    Date = (function(t) {
      var r = function Date(e, n, i, a, f, u, l) {
        const s = arguments.length
        let c
        if (this instanceof t) {
          let v = u
          let h = l
          if (dr && s >= 7 && l > yr) {
            const p = Math.floor(l / yr) * yr
            const y = Math.floor(p / 1e3)
            v += y
            h -= y * 1e3
          }
          c =
            s === 1 && o(e) === e
              ? new t(r.parse(e))
              : s >= 7
              ? new t(e, n, i, a, f, v, h)
              : s >= 6
              ? new t(e, n, i, a, f, v)
              : s >= 5
              ? new t(e, n, i, a, f)
              : s >= 4
              ? new t(e, n, i, a)
              : s >= 3
              ? new t(e, n, i)
              : s >= 2
              ? new t(e, n)
              : s >= 1
              ? new t(e instanceof t ? +e : e)
              : new t()
        } else {
          c = t.apply(this, arguments)
        }
        if (!J(c)) {
          P(c, { constructor: r }, true)
        }
        return c
      }
      const e = new RegExp(
        '^' +
          '(\\d{4}|[+-]\\d{6})' +
          '(?:-(\\d{2})' +
          '(?:-(\\d{2})' +
          '(?:' +
          'T(\\d{2})' +
          ':(\\d{2})' +
          '(?:' +
          ':(\\d{2})' +
          '(?:(\\.\\d{1,}))?' +
          ')?' +
          '(' +
          'Z|' +
          '(?:' +
          '([-+])' +
          '(\\d{2})' +
          ':(\\d{2})' +
          ')' +
          ')?)?)?)?' +
          '$',
      )
      const n = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]
      const i = function dayFromMonth(t, r) {
        const e = r > 1 ? 1 : 0
        return (
          n[r] +
          Math.floor((t - 1969 + e) / 4) -
          Math.floor((t - 1901 + e) / 100) +
          Math.floor((t - 1601 + e) / 400) +
          365 * (t - 1970)
        )
      }
      const a = function toUTC(r) {
        let e = 0
        let n = r
        if (dr && n > yr) {
          const i = Math.floor(n / yr) * yr
          const a = Math.floor(i / 1e3)
          e += a
          n -= a * 1e3
        }
        return u(new t(1970, 0, 1, 0, 0, e, n))
      }
      for (const f in t) {
        if (G(t, f)) {
          r[f] = t[f]
        }
      }
      P(r, { now: t.now, UTC: t.UTC }, true)
      r.prototype = t.prototype
      P(r.prototype, { constructor: r }, true)
      const l = function parse(r) {
        const n = e.exec(r)
        if (n) {
          const o = u(n[1])
          const f = u(n[2] || 1) - 1
          const l = u(n[3] || 1) - 1
          const s = u(n[4] || 0)
          const c = u(n[5] || 0)
          const v = u(n[6] || 0)
          const h = Math.floor(u(n[7] || 0) * 1e3)
          const p = Boolean(n[4] && !n[8])
          const y = n[9] === '-' ? 1 : -1
          const d = u(n[10] || 0)
          const g = u(n[11] || 0)
          let w
          const b = c > 0 || v > 0 || h > 0
          if (
            s < (b ? 24 : 25) &&
            c < 60 &&
            v < 60 &&
            h < 1e3 &&
            f > -1 &&
            f < 12 &&
            d < 24 &&
            g < 60 &&
            l > -1 &&
            l < i(o, f + 1) - i(o, f)
          ) {
            w = ((i(o, f) + l) * 24 + s + d * y) * 60
            w = ((w + c + g * y) * 60 + v) * 1e3 + h
            if (p) {
              w = a(w)
            }
            if (w >= -864e13 && w <= 864e13) {
              return w
            }
          }
          return NaN
        }
        return t.parse.apply(this, arguments)
      }
      P(r, { parse: l })
      return r
    })(Date)
  }
  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime()
    }
  }
  const gr =
    l.toFixed &&
    ((8e-5).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128')
  var wr = {
    base: 1e7,
    size: 6,
    data: [0, 0, 0, 0, 0, 0],
    multiply: function multiply(t, r) {
      let e = -1
      let n = r
      while (++e < wr.size) {
        n += t * wr.data[e]
        wr.data[e] = n % wr.base
        n = Math.floor(n / wr.base)
      }
    },
    divide: function divide(t) {
      let r = wr.size
      let e = 0
      while (--r >= 0) {
        e += wr.data[r]
        wr.data[r] = Math.floor(e / t)
        e = (e % t) * wr.base
      }
    },
    numToString: function numToString() {
      let t = wr.size
      let r = ''
      while (--t >= 0) {
        if (r !== '' || t === 0 || wr.data[t] !== 0) {
          const e = o(wr.data[t])
          if (r === '') {
            r = e
          } else {
            r += K('0000000', 0, 7 - e.length) + e
          }
        }
      }
      return r
    },
    pow: function pow(t, r, e) {
      return r === 0
        ? e
        : r % 2 === 1
        ? pow(t, r - 1, e * t)
        : pow(t * t, r / 2, e)
    },
    log: function log(t) {
      let r = 0
      let e = t
      while (e >= 4096) {
        r += 12
        e /= 4096
      }
      while (e >= 2) {
        r += 1
        e /= 2
      }
      return r
    },
  }
  const br = function toFixed(t) {
    let r, e, n, i, a, f, l, s
    r = u(t)
    r = Y(r) ? 0 : Math.floor(r)
    if (r < 0 || r > 20) {
      throw new RangeError(
        'Number.toFixed called with invalid number of decimals',
      )
    }
    e = u(this)
    if (Y(e)) {
      return 'NaN'
    }
    if (e <= -1e21 || e >= 1e21) {
      return o(e)
    }
    n = ''
    if (e < 0) {
      n = '-'
      e = -e
    }
    i = '0'
    if (e > 1e-21) {
      a = wr.log(e * wr.pow(2, 69, 1)) - 69
      f = a < 0 ? e * wr.pow(2, -a, 1) : e / wr.pow(2, a, 1)
      f *= 4503599627370496
      a = 52 - a
      if (a > 0) {
        wr.multiply(0, f)
        l = r
        while (l >= 7) {
          wr.multiply(1e7, 0)
          l -= 7
        }
        wr.multiply(wr.pow(10, l, 1), 0)
        l = a - 1
        while (l >= 23) {
          wr.divide(1 << 23)
          l -= 23
        }
        wr.divide(1 << l)
        wr.multiply(1, 1)
        wr.divide(2)
        i = wr.numToString()
      } else {
        wr.multiply(0, f)
        wr.multiply(1 << -a, 0)
        i = wr.numToString() + K('0.00000000000000000000', 2, 2 + r)
      }
    }
    if (r > 0) {
      s = i.length
      if (s <= r) {
        i = n + K('0.0000000000000000000', 0, r - s + 2) + i
      } else {
        i = n + K(i, 0, s - r) + '.' + K(i, s - r)
      }
    } else {
      i = n + i
    }
    return i
  }
  P(l, { toFixed: br }, gr)
  const Tr = (function() {
    try {
      return (1).toPrecision(undefined) === '1'
    } catch (t) {
      return true
    }
  })()
  const mr = l.toPrecision
  P(
    l,
    {
      toPrecision: function toPrecision(t) {
        return typeof t === 'undefined' ? mr.call(this) : mr.call(this, t)
      },
    },
    Tr,
  )
  if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
  ) {
    ;(function() {
      const t = typeof /()??/.exec('')[1] === 'undefined'
      const r = Math.pow(2, 32) - 1
      f.split = function(e, n) {
        const i = String(this)
        if (typeof e === 'undefined' && n === 0) {
          return []
        }
        if (!M(e)) {
          return Q(this, e, n)
        }
        const a = []
        const o =
          (e.ignoreCase ? 'i' : '') +
          (e.multiline ? 'm' : '') +
          (e.unicode ? 'u' : '') +
          (e.sticky ? 'y' : '')
        let f = 0
        let u
        let l
        let s
        let c
        const h = new RegExp(e.source, o + 'g')
        if (!t) {
          u = new RegExp('^' + h.source + '$(?!\\s)', o)
        }
        const p = typeof n === 'undefined' ? r : Z.ToUint32(n)
        l = h.exec(i)
        while (l) {
          s = l.index + l[0].length
          if (s > f) {
            _(a, K(i, f, l.index))
            if (!t && l.length > 1) {
              l[0].replace(u, function() {
                for (let t = 1; t < arguments.length - 2; t++) {
                  if (typeof arguments[t] === 'undefined') {
                    l[t] = void 0
                  }
                }
              })
            }
            if (l.length > 1 && l.index < i.length) {
              v.apply(a, H(l, 1))
            }
            c = l[0].length
            f = s
            if (a.length >= p) {
              break
            }
          }
          if (h.lastIndex === l.index) {
            h.lastIndex++
          }
          l = h.exec(i)
        }
        if (f === i.length) {
          if (c || !h.test('')) {
            _(a, '')
          }
        } else {
          _(a, K(i, f))
        }
        return a.length > p ? H(a, 0, p) : a
      }
    })()
  } else if ('0'.split(void 0, 0).length) {
    f.split = function split(t, r) {
      if (typeof t === 'undefined' && r === 0) {
        return []
      }
      return Q(this, t, r)
    }
  }
  const Dr = f.replace
  const Sr = (function() {
    const t = []
    'x'.replace(/x(.)?/g, function(r, e) {
      _(t, e)
    })
    return t.length === 1 && typeof t[0] === 'undefined'
  })()
  if (!Sr) {
    f.replace = function replace(t, r) {
      const e = D(r)
      const n = M(t) && /\)[*?]/.test(t.source)
      if (!e || !n) {
        return Dr.call(this, t, r)
      } else {
        const i = function(e) {
          const n = arguments.length
          const i = t.lastIndex
          t.lastIndex = 0
          const a = t.exec(e) || []
          t.lastIndex = i
          _(a, arguments[n - 2], arguments[n - 1])
          return r.apply(this, a)
        }
        return Dr.call(this, t, i)
      }
    }
  }
  const xr = f.substr
  const Or = ''.substr && '0b'.substr(-1) !== 'b'
  P(
    f,
    {
      substr: function substr(t, r) {
        let e = t
        if (t < 0) {
          e = w(this.length + t, 0)
        }
        return xr.call(this, e, r)
      },
    },
    Or,
  )
  const Er =
    '\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028' +
    '\u2029\ufeff'
  const jr = '\u200b'
  const Ir = '[' + Er + ']'
  const Mr = new RegExp('^' + Ir + Ir + '*')
  const Ur = new RegExp(Ir + Ir + '*$')
  const Fr = f.trim && (Er.trim() || !jr.trim())
  P(
    f,
    {
      trim: function trim() {
        if (typeof this === 'undefined' || this === null) {
          throw new TypeError("can't convert " + this + ' to object')
        }
        return o(this)
          .replace(Mr, '')
          .replace(Ur, '')
      },
    },
    Fr,
  )
  const Nr = d.bind(String.prototype.trim)
  const Cr =
    f.lastIndexOf && 'abc\u3042\u3044'.lastIndexOf('\u3042\u3044', 2) !== -1
  P(
    f,
    {
      lastIndexOf: function lastIndexOf(t) {
        if (typeof this === 'undefined' || this === null) {
          throw new TypeError("can't convert " + this + ' to object')
        }
        const r = o(this)
        const e = o(t)
        const n = arguments.length > 1 ? u(arguments[1]) : NaN
        const i = Y(n) ? Infinity : Z.ToInteger(n)
        const a = b(w(i, 0), r.length)
        const f = e.length
        let l = a + f
        while (l > 0) {
          l = w(0, l - f)
          const s = V(K(r, l, a + f), e)
          if (s !== -1) {
            return l + s
          }
        }
        return -1
      },
    },
    Cr,
  )
  const kr = f.lastIndexOf
  P(
    f,
    {
      lastIndexOf: function lastIndexOf(t) {
        return kr.apply(this, arguments)
      },
    },
    f.lastIndexOf.length !== 1,
  )
  if (parseInt(Er + '08') !== 8 || parseInt(Er + '0x16') !== 22) {
    parseInt = (function(t) {
      const r = /^[-+]?0[xX]/
      return function parseInt(e, n) {
        if (typeof e === 'symbol') {
          '' + e
        }
        const i = Nr(String(e))
        const a = u(n) || (r.test(i) ? 16 : 10)
        return t(i, a)
      }
    })(parseInt)
  }
  if (1 / parseFloat('-0') !== -Infinity) {
    parseFloat = (function(t) {
      return function parseFloat(r) {
        const e = Nr(String(r))
        const n = t(e)
        return n === 0 && K(e, 0, 1) === '-' ? -0 : n
      }
    })(parseFloat)
  }
  if (String(new RangeError('test')) !== 'RangeError: test') {
    const Ar = function toString() {
      if (typeof this === 'undefined' || this === null) {
        throw new TypeError("can't convert " + this + ' to object')
      }
      let t = this.name
      if (typeof t === 'undefined') {
        t = 'Error'
      } else if (typeof t !== 'string') {
        t = o(t)
      }
      let r = this.message
      if (typeof r === 'undefined') {
        r = ''
      } else if (typeof r !== 'string') {
        r = o(r)
      }
      if (!t) {
        return r
      }
      if (!r) {
        return t
      }
      return t + ': ' + r
    }
    Error.prototype.toString = Ar
  }
  if ($) {
    const Rr = function(t, r) {
      if (tt(t, r)) {
        const e = Object.getOwnPropertyDescriptor(t, r)
        if (e.configurable) {
          e.enumerable = false
          Object.defineProperty(t, r, e)
        }
      }
    }
    Rr(Error.prototype, 'message')
    if (Error.prototype.message !== '') {
      Error.prototype.message = ''
    }
    Rr(Error.prototype, 'name')
  }
  if (String(/a/gim) !== '/a/gim') {
    const $r = function toString() {
      let t = '/' + this.source + '/'
      if (this.global) {
        t += 'g'
      }
      if (this.ignoreCase) {
        t += 'i'
      }
      if (this.multiline) {
        t += 'm'
      }
      return t
    }
    RegExp.prototype.toString = $r
  }
})
// # sourceMappingURL=es5-shim.map
